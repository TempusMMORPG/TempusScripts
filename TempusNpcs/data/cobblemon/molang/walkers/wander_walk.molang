t.not_waiting = q.entity.data.next_move_time == 0 || q.system_time_millis >= q.entity.data.next_move_time;
t.should_run = (q.entity.is_doing_activity('idle') && !q.entity.has_walk_target && q.entity.config.toggle_walk && t.not_waiting);
!t.should_run ? return 0;

t.pos_radius = q.entity.config.pos_radius;
t.speed = q.entity.config.speed;

t.min_milliseconds = (q.entity.config.min_wait_time * 1000);
t.max_milliseconds = (q.entity.config.max_wait_time * 1000);

t.homeposx = q.entity.config.homeposx;
t.homeposy = q.entity.config.homeposy;
t.homeposz = q.entity.config.homeposz;

t.targetposx = math.random_integer(t.homeposx - t.pos_radius, t.homeposx + t.pos_radius);
t.targetposy = t.homeposy;
t.targetposz = math.random_integer(t.homeposz - t.pos_radius, t.homeposz + t.pos_radius);

q.entity.walk_to(t.targetposx, t.targetposy, t.targetposz, t.speed);

t.current_time = q.system_time_millis;
t.wait_time = math.random_integer(t.max_milliseconds, t.min_milliseconds);

q.entity.data.next_move_time = t.current_time + t.wait_time;
q.entity.save_data();